> 泛型的好处：
 - 把运行时出现的问题提前至了编译时；
 - 避免了无谓的强转
>泛型在集合中的应用:

 泛型中没有多态的概念。两边的数据类型必须要一致。推荐使用两边的数据类型都写上。

- ArrayList<String> list = new ArrayList<String>();
- ArrayList<String> list = new ArrayList();


> 自定义泛型
自定义泛型可以理解为是一个数据类型的占位符，或者是理解为是一个数据类型的占位符，或者是理解为是一个数据类型的变量。

> 泛型方法： 
- 定义格式：
   修饰符 返回值类型 函数名 <声明自定义泛型>（形参列表...）
   
  
 - 在方法上的自定义的具体数据类型是调用该方法的时候，传入实参的时候确定的。
 - 自定义泛型使用的标识符只要符合标识符的命名规则即可

   
 > 泛型类
- 定义格式; 
 Class 类名<声明自定义的泛型>{
     
 }
 
 
 > 注意事项
  - 1.在类上自定义的泛型的具体数据类型是在创建类对象时指定的
  - 2.在类上自定义了泛型，如果创建该类的对象时没有指定泛型的具体类型，默认是Object类型
 
 
 > 自定义一个集合对象
 
class MyList<T>{
   
    T[] arr = new T[10];
    int index = 0;
    public Mylist(){
        o = new T[10];
    }
    
    public void add(T o ){
   
      arr[index++]=0
        
    }
    
    
}

> 泛型接口
- 定义格式:interface 接口名<声明自定义的泛型>{
}
> 在接口自定义泛型要注意的事项
- 在接口上自定义泛型具体的数据类型是在实现该接口的时候指定的
- 如果一个接口自定义了泛型，在实现该接口的时候，没有指定具体的数据类型，那么默认是Object的数据类型.


- 如果想在创建接口实现类对象的时候再指定接口自定义具体数据类型。
- 实现接口的 接自定义泛型
public class Demo<T> implements Dao<T>{
    
}


interface Dao<T>{
    
    public void add(T t);
    public void remove(T t);
    
    
    
}